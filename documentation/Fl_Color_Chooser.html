<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::ColorChooser</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::ColorChooser</h2>
<hr>

<p>Shown here is the output of the function <a
href=utility.html#color_chooser><tt>fltk::color_chooser()</tt></a>,
which you may want to use.  This window contains an fltk::ColorChooser
and also two color chips below it and the ok/cancel buttons.

<P><IMG src="Fl_color_chooser.jpg"></P>

<hr>
<H3>Class Hierarchy</H3>
<PRE>
<A href=FlGroup.html#Group>fltk::Group</A>
   |
   +----<B>fltk::ColorChooser</B>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/ColorChooser.h&gt;
</PRE>
<H3>Description</H3>
 The <TT>fltk::ColorChooser</TT> widget provides a standard RGB color 
chooser.  You can place any number of these into a panel of your own 
design.  This widget contains the hue box, value slider, and rgb input 
fields from the above diagram (it does not have the color chips or the 
Cancel or OK buttons).  The callback is done every time the user 
changes the rgb value.  It is not done if they move the hue control in 
a way that produces the <I>same</I> rgb value, such as when saturation 
or value is zero. 
<H3>Methods</H3>
<UL>
<LI><A href=#ColorChooser.ColorChooser>fltk::ColorChooser</A></LI>
<LI><A href=#ColorChooser.~ColorChooser>~fltk::ColorChooser</A></LI>
</UL>
<H4><A name=ColorChooser.ColorChooser>
fltk::ColorChooser::ColorChooser(int x, int y, int w, int h, const 
char *label = 0)</A></H4>
 Creates a new <TT>fltk::ColorChooser</TT> widget using the given 
position, size, and label string. The recommended dimensions are 
200x95. The color is initialized to black. 
<H4><A name=ColorChooser.~ColorChooser>virtual 
fltk::ColorChooser::~fltk::ColorChooser()</A></H4>
 The destructor removes the color chooser and all of its controls. 
<H4><A name=ColorChooser.hue>double fltk::ColorChooser::hue() const</A>
</H4>
 Return the current hue.  0 &lt;= hue &lt; 6.  Zero is red, one is yellow, 
two is green, etc. <I>This value is convienent for the internal 
calculations - some other systems consider hue to run from zero to one, 
or from 0 to 360.</I>
<H4><A name=ColorChooser.saturation>double 
fltk::ColorChooser::saturation() const</A></H4>
 Returns the saturation.  0 &lt;= saturation &lt;= 1. 
<H4><A name=ColorChooser.value>double fltk::ColorChooser::value() 
const</A></H4>
 Returns the value/brightness.  0 &lt;= value &lt;= 1. 
<H4><A name=ColorChooser.r>double fltk::ColorChooser::r() const</A></H4>
 Returns the current red value.  0 &lt;= r &lt;= 1. 
<H4><A name=ColorChooser.g>double fltk::ColorChooser::g() const</A></H4>
 Returns the current green value.  0 &lt;= g &lt;= 1. 
<H4><A name=ColorChooser.b>double fltk::ColorChooser::b() const</A></H4>
 Returns the current blue value.  0 &lt;= b &lt;= 1. 
<H4><A name=ColorChooser.rgb>int fltk::ColorChooser::rgb(double, 
double, double)</A></H4>
 Sets the current rgb color values.  Does not do the callback.  Does 
not clamp (but out of range values will produce psychedelic effects in 
the hue selector). 
<H4><A name=ColorChooser.hsv>int 
fltk::ColorChooser::hsv(double,double,double)</A></H4>
 Set the hsv values.  The passed values are clamped (or for hue, 
modulus 6 is used) to get legal values.  Does not do the callback. 
<H4><A name=ColorChooser.hsv2rgb>static void 
fltk::ColorChooser::hsv2rgb(double, double, double, double&amp;, double&amp;, 
double&amp;)</A></H4>
 This <I>static</I> method converts HSV colors to RGB colorspace. 
<H4><A name=ColorChooser.rgb2hsv>static void 
fltk::ColorChooser::rgb2hsv(double, double, double, double&amp;, double&amp;, 
double&amp;)</A></H4>
 This <I>static</I> method converts RGB colors to HSV colorspace. </BODY>
</HTML>