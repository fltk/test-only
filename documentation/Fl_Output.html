<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::Output</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::Output</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=Fl_Input.html#Input>fltk::Input</A>
   |
   +----<B>fltk::Output</B>
           |
           +----<A href=Fl_MultilineOutput.html#MultilineOutput>fltk::MultilineOutput</A>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/Output.h&gt;
</PRE>
<H3>Description</H3>
 This widget displays a piece of text.  When you set the <TT>value()</TT>
, <TT>fltk::Output</TT> does a <TT>strcpy()</TT> to it's own storage, 
which is useful for program-generated values.  The user may select 
portions of the text using the mouse and paste the contents into other 
fields or programs. 
<CENTER><IMG src=./text.gif></CENTER>
<P>There is a single subclass, <A href=Fl_MultilineOutput.html#MultilineOutput>
fltk::MultilineOutput</A>, which allows you to display multiple lines of 
text. </P>
<P>The text may contain any characters except \0, and will correctly 
display anything, using ^X notation for unprintable control characters 
and \nnn notation for unprintable characters with the high bit set. It 
assummes the font can draw any characters in the ISO-Latin1 character 
set. </P>
<H3>Methods</H3>
<UL>
<LI><A href=#Output>fltk::Output</A></LI>
<LI><A href=#~fltk::Output>~fltk::Output</A></LI>
<LI><A href=#cursor_color>cursor_color</A></LI>
<LI><A href=#index>index</A></LI>
<LI><A href=#size>size</A></LI>
<LI><A href=#value>value</A></LI>
</UL>
<H4><A name=Output>fltk::Output::Output(int x, int y, int 
w, int h, const char *label = 0)</A></H4>
 Creates a new <TT>fltk::Output</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>fltk::DOWN_BOX</TT>. 
<H4><A name=~Output>virtual fltk::Output::~fltk::Output()</A></H4>
 Destroys the widget and any value associated with it. 
<H4><A name=value>const char *fltk::Output::value() const
<BR> int fltk::Output::value(const char*)
<BR> int fltk::Output::value(const char*, int)</A></H4>
 The first form returns the current value, which is a pointer to the 
internal buffer and is valid only until the value is changed. 
<P>The second two forms change the text and set the mark and the point 
to the end of it. The string is copied to the internal buffer.  Passing <TT>
NULL</TT> is the same as &quot;&quot;.  This returns non-zero if the new value is 
different than the current one.  You can use the second version to 
directly set the length if you know it already or want to put nul's in 
the text. </P>
<H4><A name=size>int fltk::Output::size() const</A></H4>
 Returns the number of characters in <TT>value()</TT>.  This may be 
greater than <TT>strlen(value())</TT> if there are nul characters in 
it. 
<H4><A name=index>char fltk::Output::index(int) const</A></H4>
 Same as <TT>value()[n]</TT>, but may be faster in plausible 
implementations. No bounds checking is done. 
</BODY></HTML>
