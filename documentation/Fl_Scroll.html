<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::Scroll</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::Scroll</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=FlGroup.html#Group>fltk::Group</A>
   |
   +----<B>fltk::Scroll</B>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/Scroll.h&gt;
</PRE>
<H3>Description</H3>
 This container widget lets you maneuver around a set of widgets much 
larger than your window.  If the child widgets are larger than the size 
of this object then scrollbars will appear so that you can scroll over 
to them: 
<P ALIGN=CENTER><IMG src=Fl_Scroll.gif></P>
<P>If all of the child widgets are packed together into a solid 
rectangle then you want to set <TT>box()</TT> to <TT>fltk::NO_BOX</TT> or 
one of the <TT>_FRAME</TT> types. This will result in the best output. 
 However, if the child widgets are a sparse arrangment you must set <TT>
box()</TT> to a real <TT>_BOX</TT> type.  This can result in some 
blinking during redrawing, but that can be solved by using a <TT>
fltk::DoubleBufferWindow</TT>. </P>
<P>This widget can also be used to pan around a single child widget 
&quot;canvas&quot;.  This child widget should be of your own class, with a <TT>
draw()</TT> method that draws the contents.  The scrolling is done by 
changing the <TT>x()</TT> and <TT>y()</TT> of the widget, so this child 
must use the <TT>x()</TT> and <TT>y()</TT> to position it's drawing. 
 To speed up drawing it should test <A href="drawing.html#not_clipped"><TT>fltk::not_clipped()</TT></A>
. </P>
<P>Another very useful child is a single <A href=Fl_Pack.html#Pack><TT>
fltk::Pack</TT></A>, which is itself a group that packs it's children 
together and changes size to surround them.  Filling the <TT>fltk::Pack</TT>
 with <A href=Fl_Tabs.html><TT>fltk::Tabs</TT></A> groups (and then putting 
normal widgets inside those) gives you a very powerful scrolling list 
of individually-openable panels. </P>
<P>Fluid lets you create these, but you can only lay out objects that 
fit inside the <TT>fltk::Scroll</TT> without scrolling.  Be sure to leave 
space for the scrollbars, as Fluid won't show these either. </P>
<P><I>You cannot use <TT>fltk::Window</TT> as a child of this since the 
clipping is not conveyed to it when drawn, and it will draw over the 
scrollbars and neighboring objects.</I></P>
<H3>Methods</H3>
<UL>
<LI><A href=#Scroll.Scroll>fltk::Scroll</A></LI>
<LI><A href=#Scroll.~Scroll>~fltk::Scroll</A></LI>
<LI><A href=#Scroll.align>align</A></LI>
<LI><A href=#Scroll.position>position</A></LI>
<LI><A href=#Scroll.type>type</A></LI>
<LI><A href=#Scroll.xposition>xposition</A></LI>
<LI><A href=#Scroll.yposition>yposition</A></LI>
</UL>
<H4><A name=Scroll.Scroll>fltk::Scroll::Scroll(int x, int y, int 
w, int h, const char *label = 0)</A></H4>
 Creates a new <TT>fltk::Scroll</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>fltk::NO_BOX</TT>. 
<H4><A name=Scroll.~Scroll>virtual fltk::Scroll::~fltk::Scroll()</A></H4>
 The destructor <I>also deletes all the children</I>. This allows a 
whole tree to be deleted at once, without having to keep a pointer to 
all the children in the user code. A kludge has been done so the <TT>
fltk::Scroll</TT> and all of it's children can be automatic (local) 
variables, but you must declare the <TT>fltk::Scroll</TT><I>first</I>, so 
that it is destroyed last. 
<H4><A name=Scroll.type>void fltk::Widget::type(int)</A></H4>
 By default you can scroll in both directions, and the scrollbars 
disappear if the data will fit in the area of the scroll. <TT>type()</TT>
 can change this: 
<UL>
<LI><TT>0</TT> - No scrollbars </LI>
<LI><TT>fltk::Scroll::HORIZONTAL</TT> - Only a horizontal scrollbar. </LI>
<LI><TT>fltk::Scroll::VERTICAL</TT> - Only a vertical scrollbar. </LI>
<LI><TT>fltk::Scroll::BOTH</TT> - The default is both scrollbars. </LI>
<LI><TT>fltk::Scroll::HORIZONTAL_ALWAYS</TT> - Horizontal scrollbar 
 always on, vertical always off. </LI>
<LI><TT>fltk::Scroll::VERTICAL_ALWAYS</TT> - Vertical scrollbar always on, 
 horizontal always off. </LI>
<LI><TT>fltk::Scroll::BOTH_ALWAYS</TT> - Both always on. </LI>
</UL>
<H4><A name=Scroll.align>void fltk::Scroll::scrollbar.align(int)
<BR> void fltk::Scroll::hscrollbar.align(int)</A></H4>
 This is used to change what side the scrollbars are drawn on.  If the <TT>
fltk::ALIGN_LEFT</TT> bit is on, the vertical scrollbar is on the left. 
 If the <TT>fltk::ALIGN_TOP</TT> bit is on, the horizontal scrollbar is on 
the top. 
<H4><A name=Scroll.xposition>int fltk::Scroll::xposition() const</A></H4>
 Gets the current horizontal scrolling position. 
<H4><A name=Scroll.yposition>int fltk::Scroll::yposition() const</A></H4>
 Gets the current vertical scrolling position. 
<H4><A name=Scroll.position>void fltk::Scroll::position(int w, int h)</A>
</H4>
 Sets the upper-lefthand corner of the scrolling region. </BODY></HTML>
