<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::DoubleBufferWindow</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::DoubleBufferWindow</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=Fl_Window.html#Window>fltk::Window</A>
   |
   +----<B>fltk::DoubleBufferWindow</B>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/DoubleBufferWindow.h&gt;
</PRE>
<H3>Description</H3>
 The <TT>fltk::DoubleBufferWindow</TT> class provides a double-buffered window. 
 If possible this will use the X double buffering extension (Xdbe).  If 
not, it will draw the window data into an off-screen pixmap, and then 
copy it to the on-screen window. 
<P>It is highly recommended that you put the following code before the 
first <TT>show()</TT> of <I>any</I> window in your program: </P>
<PRE>
fltk::visual(fltk::DOUBLE|fltk::INDEX)
</PRE>
 This makes sure you can use Xdbe on servers where double buffering 
does not exist for every visual. 
<H3>Methods</H3>
<UL>
<LI><A href="#DoubleBufferWindow">fltk::DoubleBufferWindow</A></LI>
<LI><A href="#~fltk::DoubleBufferWindow">~fltk::DoubleBufferWindow</A></LI>
<LI><A href="#pixmap">pixmap</A></LI>
</UL>
<H4><A name="DoubleBufferWindow">
fltk::DoubleBufferWindow::DoubleBufferWindow(int x, int y, int w, int h, const 
char *label = 0)</A></H4>
 Creates a new <TT>fltk::DoubleBufferWindow</TT> widget using the given 
position, size, and label (title) string. 
<H4><A name="~fltk::DoubleBufferWindow">virtual 
fltk::DoubleBufferWindow::~fltk::DoubleBufferWindow()</A></H4>
 The destructor <I>also deletes all the children</I>. This allows a 
whole tree to be deleted at once, without having to keep a pointer to 
all the children in the user code. 
<H4><A name="pixmap">ulong fltk::DoubleBufferWindow::pixmap() const</a></h4>

Returns the off-screen pixmap or back buffer. This value is zero until
the first time <tt>flush()</tt> is called.

</body></html>
