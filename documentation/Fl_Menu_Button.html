<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::MenuButton</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::MenuButton</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=Fl_Menu.html#Menu>fltk::Menu</A>
   |
   +----<B>fltk::MenuButton</B>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/MenuButton.h&gt;
</PRE>
<H3>Description</H3>
 This is a button that when pushed pops up a menu (or hierarchy of 
menus) defined by an array of <A href=Fl_MenuItem.html><TT>
fltk::MenuItem</TT></A> objects. 
<P ALIGN=CENTER><IMG src=menu_button.gif></P>
<P>Normally any mouse button will pop up a menu and it is lined up 
below the button as shown in the picture.  However an <TT>fltk::MenuButton</TT>
 may also control a pop-up menu.  This is done by setting the <TT>type()</TT>
, see below. </P>
<P>The menu will also pop up in response to shortcuts indicated by 
putting a '&amp;' character in the <TT>label()</TT>. </P>
<P>Typing the <TT>shortcut()</TT> of any of the menu items will cause 
callbacks exactly the same as when you pick the item with the mouse. 
 The '&amp;' character in menu item names are only looked at when the menu is 
popped up, however. </P>
<P>When the user picks an item off the menu, the item's callback is 
done with the menu_button as the <TT>fltk::Widget*</TT> argument.  If the 
item does not have a callback the menu_button's callback is done 
instead. </P>
<H3>Methods</H3>
<UL>
<LI><A href=#MenuButton.MenuButton>fltk::MenuButton</A></LI>
<LI><A href=#MenuButton.~MenuButton>~fltk::MenuButton</A></LI>
<LI><A href=#MenuButton.popup>popup</A></LI>
<LI><A href=#MenuButton.type>type</A></LI>
</UL>
<H4><A name=MenuButton.MenuButton>
fltk::MenuButton::MenuButton(int x, int y, int w, int h, const char 
*label = 0)</A></H4>
 Creates a new <TT>fltk::MenuButton</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>fltk::UP_BOX</TT>. 
<P>The constructor sets <TT>menu()</TT> to <TT>NULL</TT>.  See <A href=Fl_Menu.html#Menu>
<TT>fltk::Menu</TT></A> for the methods to set or change the menu. </P>
<H4><A name=MenuButton.~MenuButton>virtual 
fltk::MenuButton::~fltk::MenuButton()</A></H4>
 The destructor removes the <TT>fltk::MenuButton</TT> widget and all of 
its menu items. 
<H4><A name=MenuButton.popup>const fltk::Menu* fltk::MenuButton::popup()</A>
</H4>
 Act exactly as though the user clicked the button or typed the 
shortcut key.  The menu appears, it waits for the user to pick an item, 
and if they pick one it sets <TT>value()</TT> and does the callback or 
sets <TT>changed()</TT> as described above.  The menu item is returned 
or <TT>NULL</TT> if the user dismisses the menu. 
<H4><A name=MenuButton.type>void fltk::MenuButton::type(uchar)</A></H4>
 If <TT>type()</TT> is zero a normal menu button is produced.  If it is 
nonzero then this is a pop-up menu.  The bits in <TT>type()</TT>
 indicate what mouse buttons pop up the menu.  For convienece the 
constants <TT>fltk::MenuButton::POPUP1, POPUP2, POPUP3, POPUP12, POPUP13, 
POPUP23</TT>, and <TT>POPUP123</TT> are defined. <TT>
fltk::MenuButton::POPUP3</TT> is usually what you want. 
<P>A popup menu button is invisible and does not interfere with any 
events other than the mouse button specified (and any shortcuts).  The 
widget can be stretched to cover all your other widgets by putting it 
last in the hierarchy so it is &quot;on top&quot;.  You can also make several 
widgets covering different areas for context-sensitive popup menus. </P>
<P>The popup menus appear with the cursor pointing at the previously 
selected item.  This is a <I>feature</I>.  If you don't like it, do <TT>
value(0)</TT> after the menu items are picked to forget the current 
item. </P>
</BODY></HTML>
