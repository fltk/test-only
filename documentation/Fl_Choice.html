<html><head><link href="fltk.css" rel="stylesheet" type="text/css">
<title>class fltk::Choice</title></head><body>
<!-- NEW PAGE -->
<h2>class fltk::Choice</h2>
<hr>

<H3>Class Hierarchy</H3>
<PRE>
<A href=Fl_Menu.html#Menu>fltk::Menu</A>
   |
   +----<B>fltk::Choice</B>
</PRE>
<H3>Include Files</H3>
<PRE>
#include &lt;fltk/Choice.h&gt;
</PRE>
<H3>Description</H3>

This is a button that when pushed pops up a menu (or hierarchy of
menus) defined by an array of child items. The appearance is designed
to look like a Windows "combo box" but it is somewhat different in
that it does not contain a text editor, also the menu pops up with the
current item under the cursor, which is immensely easier to use once
you get used to it.  Motif calls this an OptionButton.

<p><center><img src=choice.gif></center>

<p>The user can change the value by popping up the menu by clicking
anywhere in the widget and moving the cursor to a different item, or
by typing up and down arrow keys to cycle amoung the items.  Typing
the <a href="Fl_Widget.html#shortcut">shortcut()</a> of any of the
items will also change the value to that item (The '&amp;' character
in item names are only looked at when the menu is popped up,
however).</P>

<p>The menu will also pop up in response to shortcuts indicated by
putting a '&amp;' character in the label() or to the 
<a href="Fl_Widget.html#shortcut">shortcut()</a> of the fltk::Choice
widget itself. The user can then use arrow keys or the mouse to change
the selected item.

<P>When the user changes the value() the callback is done.

<H3>Methods</H3>
<UL>
<LI><A href=#Choice.Choice>fltk::Choice</A></LI>
<LI><A href=#Choice.~Choice>~fltk::Choice</A></LI>
<LI><A href=#Choice.clear_changed>clear_changed</A></LI>
<LI><A href=#Choice.changed>changed</A></LI>
<LI><A href=#Choice.down_box>down_box</A></LI>
<LI><A href=#Choice.set_changed>set_changed</A></LI>
<LI><A href=#Choice.value>value</A></LI>
</UL>
<H4><A name=Choice.Choice>fltk::Choice::Choice(int x, int y, int 
w, int h, const char *label = 0)</A></H4>
 Creates a new <TT>fltk::Choice</TT> widget using the given position, 
size, and label string. The default boxtype is <TT>fltk::UP_BOX</TT>. 
<P>The constructor sets <TT>menu()</TT> to <TT>NULL</TT>.  See <A href=Fl_Menu.html#Menu>
<TT>fltk::Menu</TT></A> for the methods to set or change the menu. </P>
<H4><A name=Choice.~Choice>virtual fltk::Choice::~fltk::Choice()</A></H4>
 The destructor removes the <TT>fltk::Choice</TT> widget and all of its 
menu items. 
<H4><A name=Choice.value>int fltk::Choice::value() const
<BR> int fltk::Choice::value(int)
<BR> int fltk::Choice::value(const fltk::Menu *)</A></H4>
 The value is the index into the <TT>fltk::Menu</TT> array of the last 
item chosen by the user.  It is zero initially.  You can set it as an 
integer, or set it with a pointer to a menu item.  The set routines 
return non-zero if the new value is different than the old one. 
 Changing it causes a <TT>redraw()</TT>. 
<H4><A name=Choice.changed>int fltk::Widget::changed() const</A></H4>
 This value is true if the user picks a different value. <I>It is 
turned off by <TT>value()</TT> and just before doing a callback (the 
callback can turn it back on if desired).</I>
<H4><A name=Choice.set_changed>void fltk::Widget::set_changed()</A></H4>
 This method sets the <TT>changed()</TT> flag. 
<H4><A name=Choice.clear_changed>void fltk::Widget::clear_changed()</A></H4>
 This method clears the <TT>changed()</TT> flag. 
<H4><A name=Choice.down_box>fltk::Box fltk::Choice::down_box() const
<BR> void fltk::Choice::down_box(fltk::Box b)</A></H4>
 The first form gets the current down box, which is used when the menu 
is popped up.  The default down box type is <TT>fltk::DOWN_BOX</TT> The 
second form sets the current down box type to <TT>b</TT>. </BODY></HTML>